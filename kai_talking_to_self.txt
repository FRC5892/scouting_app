Okay. So I'm going to have to burn the home screen to the ground.
In FormsHome, the "Add" button in the AppBar needs to be able to update the same State that the body is under.
Meaning I can't keep them separate anymore.
The main reason I separated them is so they could be separated from the BottomNavigationBar.
That definitely needs to be separate... unless HomeViews are responsible for rendering it themselves?
Huh. This seems like a good idea.
HomeView probably couldn't be an interface at that point tho.
Maybe make a static method in HomeView for rendering the bar?
Anything that implements HomeView (all both of them) would need to provide their index to the navbar.
Then each HomeView's build() method would build a Scaffold and put the navbar in its place.
The HomeScreen would only need to manage showing the proper view at the proper time.
Maybe use a GlobalKey for the appbar/navbar? It might be necessary. Don't overcomplicate it if it looks good without one.

...you know what? Let's just use a Stream. That seems way less complicated.
Time to go look up how Streams work.

~~~

Booyeah I didn't have to do the home screen over again.
Now time to do forms over again.
The way I am currently doing forms, it will be hard to actually look at the data a form contains.
By look at I mean with human eyes, on a screen, in a format that makes sense to the JSON-illiterate.
So. Planning.
The way a form is set up can be defined by a class. Let's call it FRCFormType.
Instead of overriding an abstract class, forms will be defined by being FRCFormType objects.
Each FRCFormType will know its own codeName and be able to:
 - create a Scaffold for the purpose of entering data
 - take a JSON map and create a Scaffold that displays it
Let's also have an FRCFormTypeManager that handles all of this. Takes in a codeName, spits out a form type.
FRCFormTypes will have to register themselves with this in the constructor.
How about a similar "static instance" pattern to StorageManager? Seems p legit.
Also... FRCFormFieldType. That will totally need to be a thing. FRCFormTypeManager can handle managing them tho.
Again, they will need to be able to render themselves for both entry and display.
Bonus points if I can override the fields' default values (e.g. form editing).
Form editing seems hard tho. Maybe later. At least deleting will definitely be important.

What have I done so far?
FRCFormTypes and FRCFormFieldTypes can build themselves, so that's pretty cool.
But, in order to do viewing/editing, I'll have to have some class for a FormField that knows what type of field it is and what its key in the JSON is.
...
Or have an ordered list of keys in each FRCFormType?
The type is responsible for sorting the JSON and passes that to the fields.
This seems like a really stupid way to do it, but I can't see any immediate downfalls.
Maybe add a convenience method for adding a field type and a key at the same time.
Heck, when an FRCFormType is building for any sort of entry, it probably needs to know what its key is.
This is so many typedefs. So so many.
Hm. Maybe there should be classes for maintaining forms in whatever view they're using?
That's a really bad way to explain my idea. Hopefully I can code it before I forget it.

Also just remembered that fields will need custom titles. "Number of balls shot" or "Number of robots exploded" or something. Bluh.
FRCFormFieldType will definitely need some class that holds all of this info for use when building the form.
SIGH. All of these classes probably go in separate files anyway.

~~~

Time to start integrating Firebase.
Cloud Firestore looks cool. And Flutter is still in alpha, so what's the harm in making another not-fully-released tool integral to the app's basic functionality?
I don't know a better place to put this, so here are the access rules I came up with:

service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userID} {
      allow read, write: if request.auth.uid == userID;
    }
    match /data/{teamCode} {
      function canAccess() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)/teamCode) == teamCode &&
               get(/databases/$(database)/documents/users/$(request.auth.uid)/teamPass) == get(/databases/$(database)/documents/data/$(teamCode)/teamPass);
      }
    	allow read, write: if canAccess();
      allow create;
      match /teamPass {
      	allow create;
      }
      match /{allChildren=**} {
      	allow read, write: if canAccess();
      }
    }
  }
}

IntroScreen will give users the choice to create or join a team. teamCode will just be some generated string, while the team will decide on teamPass.
Encourage teamPass to be something stupidly obvious to the team. Like the team number. Or team name.
Actually, does there need to be a teamPass? Yes: security through obscurity is bad practice.
I don't want to make user authentication a huge deal. Ideally, the app will just make up a userID the first time it is run, save it, and authenticate with it.
Maybe two IDs, in case Firebase yells at me for not having a password. Actually two is probably better anyway.

Welp. Just looked up how to actually do custom auth. That isn't going to work.
So... people are going to have to sign in with, like, a Google account or something.
RIP the nonintrusive authentication process.
Or maybe do it anonymously? How would that work.
The app would store teamCode, teamPass, and the user's name. Every time you push/pull, you sign in as a new anonymous user.
Can teamPass just be added as, like, a request header or something?
Doesn't look like it.
Boy it sure would be nice if email/password sign-in didn't require an email.
I could have the anonymous user add its credentials to "users", make its push/query, then delete itself.
Let's take another look at custom authentication. What would it take to make that work?
The instructions say that a JWT must be generated and sent to the client app.
The Firebase Admin SDK has this built in, but is not available for Dart, so that's a no go.
Alternately, if your language has a JWT library, you can generate it like that and send it to the client app.
Generating it in the client app would make that really easy..? No. Generating it requires a private key.
There has to be a way to do this. I get that this isn't Firebase's exact use case, but it should be close enough, right?
Maybe add fields to the anonymous auth token? That looks like a thing you should be able to do.

Okay. Here's the plan.
Whenever the app needs to push or get from the database, it will sign in with a new anonymous account.
The app will put teamPass into its own document from "users" along with a timestamp in case cleanup is needed later.
"users" doesn't need to store teamCode, that should be apparent from the request/query. (I should probably make a new text file to put the current storage rules.)
After that, the app will do whatever it needs to, delete its "users" info, and sign out.
Seems pretty legit, as long as I make sure it doesn't try to sign in multiple times or something.

Well crap. It's refusing to compile now.
I think this is probably a good time to commit.